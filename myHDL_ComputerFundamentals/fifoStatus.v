// File: fifoStatus.v
// Generated by MyHDL 0.10
// Date: Thu Aug  9 07:54:14 2018


`timescale 1ns/10ps

module fifoStatus (
    wr,
    rd,
    fifo_we,
    fifo_rd,
    wptr,
    rptr,
    fifo_full,
    fifo_empty,
    fifo_threshold,
    fifo_overflow,
    fifo_underflow,
    clk,
    rst_n
);
// Input:
//     wr(bool): write signal
//     rd(bool): read signal 
//     fifo_we(bool): write enable signal
//     fifo_rd(bool): read enable signal
//     wptr(5bit): write pointer 
//     rptr(5bit): read pointer
//     clk(bool): clock
//     rst_n(bool): reset 
//     
// Ouput:
//     fifo_full(bool): signal indicating the fifo memory is full
//     fifo_empty(bool):signal indicating the fifo memory is empty
//     fifo_threshold(bool): signal indicating that the fifo is about to overflow
//     fifo_overflow(bool): signal indicating that the fifo rptr has overflowed
//     fifo_underflow(bool): signal indicating that the fifo wptr has underflowed

input wr;
input rd;
input fifo_we;
input fifo_rd;
input [4:0] wptr;
input [4:0] rptr;
output fifo_full;
wire fifo_full;
output fifo_empty;
wire fifo_empty;
output fifo_threshold;
wire fifo_threshold;
output fifo_overflow;
wire fifo_overflow;
output fifo_underflow;
wire fifo_underflow;
input clk;
input rst_n;

reg underflow_set = 0;
reg signed [4:0] pointer_result = 0;
reg pointer_equal = 0;
reg overflow_set = 0;
reg fifo_underflow_i = 0;
reg fifo_threshold_i = 0;
reg fifo_overflow_i = 0;
reg fifo_full_i = 0;
reg fifo_empty_i = 0;
reg fbit_comp = 0;



always @(rptr, fifo_empty_i, wr, rd, fifo_full_i, wptr) begin: FIFOSTATUS_LOGIC1
    fbit_comp = (wptr[4] ^ rptr[4]);
    if (($signed({1'b0, wptr[3-1:0]}) - rptr[3-1:0])) begin
        pointer_equal = 0;
    end
    else begin
        pointer_equal = 1;
    end
    pointer_result = (wptr[4-1:0] - rptr[4-1:0]);
    overflow_set = (fifo_full_i & wr);
    underflow_set = (fifo_empty_i & rd);
end


always @(fbit_comp, pointer_equal, pointer_result) begin: FIFOSTATUS_LOGIC2
    fifo_full_i = (fbit_comp & pointer_equal);
    fifo_empty_i = ((!fbit_comp) & pointer_equal);
    if ((pointer_result[4] || pointer_result[3])) begin
        fifo_threshold_i = 1;
    end
    else begin
        fifo_threshold_i = 0;
    end
end


always @(posedge clk, negedge rst_n) begin: FIFOSTATUS_OVERFLOWCONTROL
    if (rst_n) begin
        fifo_overflow_i <= 0;
    end
    else if (((overflow_set == 1) && (fifo_rd == 0))) begin
        fifo_overflow_i <= 1;
    end
    else if (fifo_rd) begin
        fifo_overflow_i <= 0;
    end
    else begin
        fifo_overflow_i <= fifo_overflow_i;
    end
end


always @(posedge clk, negedge rst_n) begin: FIFOSTATUS_UNDERFLOWCONTROL
    if (rst_n) begin
        fifo_underflow_i <= 0;
    end
    else if (((underflow_set == 1) && (fifo_we == 0))) begin
        fifo_underflow_i <= 1;
    end
    else if (fifo_we) begin
        fifo_underflow_i <= 0;
    end
    else begin
        fifo_underflow_i <= fifo_underflow_i;
    end
end



assign fifo_full = fifo_full_i;
assign fifo_empty = fifo_empty_i;
assign fifo_threshold = fifo_threshold_i;
assign fifo_overflow = fifo_overflow_i;
assign fifo_underflow = fifo_underflow_i;

endmodule
